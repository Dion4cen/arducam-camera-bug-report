#!/usr/bin/python3
#
# This file is part of the libcamera-apps package (https://github.com/raspberrypi/libcamera-apps/blob/main/utils/camera-bug-report).
# Copyright (c) 2023 naushir.
#
# Arducam libcamera-apps bug report generator.
# MODIFIED:
# - To support Bullseye (libcamera-still), Bookworm (rpicam-still), and Trixie (rpicam-still).
# - To add a default 8-second timeout to the camera command to prevent hangs.
#

import argparse
import select
import subprocess
import sys
import time
from datetime import datetime

def get_os_codename():
    """
    Parses /etc/os-release to find the VERSION_CODENAME.
    This is the most reliable way to distinguish Bullseye, Bookworm, and Trixie.
    """
    try:
        with open('/etc/os-release', 'r') as f:
            for line in f:
                if line.startswith('VERSION_CODENAME='):
                    # Return the codename, stripped of potential quotes
                    return line.strip().split('=')[1].strip('\"')
    except FileNotFoundError:
        print("Warning: /etc/os-release not found. Falling back to Bullseye defaults.", file=sys.stderr)
        return 'bullseye'
    return 'bullseye' # Default fallback


class Report:
    def __init__(self, id, file):
        self._id = id
        self._cmds = []
        self._strs = []
        self._file = file

    def __run_cmd(self, cmd):
        print(f'** {cmd} **', file=self._file)
        try:
            p = subprocess.run(cmd, text=True, check=False, shell=True,
                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            print(p.stdout, file=self._file)
        except RuntimeError as e:
            print(f'Error: {e}', file=self._file)

    def add_cmd(self, c):
        self._cmds.append(c)

    def add_str(self, s):
        self._strs.append(s)

    def exec(self):
        print(f'{"-"*80}\\n{self._id}\\n{"-"*80}', file=self._file)
        for c in self._cmds:
            self.__run_cmd(c)
        for s in self._strs:
            print(s, file=self._file)


def run_prog(cmd, t):
    cmd = cmd.split(' ')
    out = []
    try:
        start = time.time()
        p = subprocess.Popen(cmd, text=True, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT, errors='ignore')
        poll = select.poll()
        poll.register(p.stdout, select.POLLIN)
        while p.poll() is None:
            if poll.poll(0):
                line = p.stdout.readline()
                print(line, end='', flush=True)
                out.append(line)
            # This is the timeout logic, it will now trigger by default
            if (t != 0) and (time.time() - start > t):
                p.kill()
                out = out + p.communicate()[0].splitlines(keepends=True)
                out.append('\\nError: ***** TIMEOUT after ' + str(t) + ' seconds *****\\n')
                break
    except KeyboardInterrupt:
        p.kill()
        out = out + p.communicate()[0].splitlines(keepends=True)
        out.append('\\nError: ***** INTERRUPT *****\\n')
    p.wait()
    return ''.join(out)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='libcamera-apps Bug Report Generator')
    parser.add_argument('-o', help='Report filename',
                        type=str, default='arducam-bug-report.txt')

    # --- (START) Arducam Optimization: Set default timeout ---
    # Changed default from 0 to 8.0 to prevent camera hangs.
    parser.add_argument('-t', help='Timeout (seconds) for the camera command. The script will terminate '
                        'the command if it runs longer than this. Default is 8 seconds. Set to 0 to disable.',
                        type=float, default=8.0)
    # --- (END) Arducam Optimization ---

    parser.add_argument('-c', help='Command to run, e.g., -c "libcamera-still -t 5000 -n -o arducam-test.jpg"',
                        type=str, default=None)

    args = parser.parse_args()

    os_codename = get_os_codename()

    if args.c is None:
        # --- (START) Trixie OS Support Added ---
        if os_codename in ['bookworm', 'trixie']:
            print(f"[INFO] {os_codename.capitalize()} OS detected. Defaulting to 'rpicam-still'.")
            # Note: The command's own timeout (-t 1000) is separate from the script's watchdog timeout.
            args.c = 'rpicam-still -n -t 1000 -o arducam-test.jpg --width 1920 --height 1080'
        # --- (END) Trixie OS Support ---
        else:
            print("[INFO] Bullseye or other OS detected. Defaulting to 'libcamera-still'.")
            args.c = 'libcamera-still -n -t 1000 -o arducam-test.jpg --width 1920 --height 1080'

    app = args.c.split(" ")[0]

    # --- (START) Trixie OS Support Added ---
    list_cameras_flag = '--list' if os_codename in ['bookworm', 'trixie'] and app.startswith('rpicam-') else '--list-cameras'
    # --- (END) Trixie OS Support ---


    reports = []
    with open(args.o, 'wt') as file:
        title = Report('libcamera-apps Bug Report', file)
        title.add_str(f'Date: {datetime.now().strftime("%d-%m-%Y (%H:%M:%S)")}')
        title.add_str(f'Command: {" ".join(sys.argv)}\\n')
        reports.append(title)

        hwinfo = Report('Hardware information', file)
        hwinfo.add_cmd('hostname')
        hwinfo.add_cmd('uname -r')
        hwinfo.add_cmd('cat /proc/cpuinfo | tail -n 4')
        reports.append(hwinfo)

        libcamerainfo = Report('libcamera verison', file)
        libcamerainfo.add_cmd('sudo dpkg -l | grep libcamera')
        reports.append(libcamerainfo)

        camera = Report('Camera detect', file)
        camera.add_cmd('ls /dev/video*')
        reports.append(camera)

        config = Report('Configuration', file)
        # Modified to handle both potential config file locations
        config.add_cmd('if [ -f /boot/config.txt ]; then cat /boot/config.txt; else echo "/boot/config.txt not found."; fi')
        config.add_cmd('if [ -f /boot/firmware/config.txt ]; then cat /boot/firmware/config.txt; else echo "/boot/firmware/config.txt not found."; fi')
        config.add_cmd('ls /boot/overlays/* | grep arducam')
        config.add_cmd('ls /boot/overlays/* | grep imx')
        config.add_cmd('ls /lib/modules/$(uname -r)/kernel/drivers/media/i2c')
        config.add_cmd('i2cdetect -y -r 10')
        reports.append(config)

        mem = Report('Memory', file)
        mem.add_cmd('cat /proc/meminfo | grep Cma')
        reports.append(mem)

        cam = Report('Cameras', file)
        cam.add_cmd(f'{app} {list_cameras_flag}')
        reports.append(cam)

        ver = Report('Versions', file)
        ver.add_cmd('uname -a')
        ver.add_cmd('cat /etc/os-release')
        reports.append(ver)

        if args.c:
            print(f"--- Running camera command with a {args.t}-second timeout ---")
            cmd_out = run_prog(args.c, args.t)
            cmd = Report(f'Command Output: {args.c}', file)
            cmd.add_str(cmd_out)
            reports.append(cmd)

        logs = Report('Logs', file)
        logs.add_cmd("ls -lh arducam-test.jpg")
        logs.add_cmd('dmesg | grep arducam')
        logs.add_cmd('dmesg | grep imx')
        logs.add_cmd('dmesg | grep ov9281')
        logs.add_cmd('dmesg | tail -n 100') # Showing last 100 lines of dmesg is often more useful than the whole log
        reports.append(logs)

        for r in reports:
            r.exec()

        print(f'\\nBug report generated to {args.o}')
        print('Please upload this file when you contact support@arducam.com')
