#!/usr/bin/python3
#
# This file is part of the libcamera-apps package (https://github.com/raspberrypi/libcamera-apps/blob/main/utils/camera-bug-report).
# Copyright (c) 2023 naushir.
#
# Arducam libcamera-apps bug report generator.
# MODIFIED:
# - To support Bullseye (libcamera-still), Bookworm (rpicam-still), and Trixie (rpicam-still).
# - To add a default 8-second timeout to the camera command to prevent hangs.
# - To fix the OS detection function to be more robust.
#

import argparse
import select
import subprocess
import sys
import time
from datetime import datetime

def get_os_codename():
    """
    Parses /etc/os-release to find the VERSION_CODENAME.
    This function is more robust and handles variations in the file format.
    """
    try:
        os_info = {}
        with open('/etc/os-release', 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if '=' in line:
                    key, value = line.split('=', 1)
                    # Remove potential quotes from the value, e.g., "trixie" -> trixie
                    os_info[key] = value.strip('"\'')
        
        codename = os_info.get('VERSION_CODENAME')
        if codename:
            return codename
        else:
            # Fallback if VERSION_CODENAME is not found
            print("Warning: VERSION_CODENAME not found in /etc/os-release. Falling back to Bullseye defaults.", file=sys.stderr)
            return 'bullseye'

    except FileNotFoundError:
        print("Warning: /etc/os-release not found. Falling back to Bullseye defaults.", file=sys.stderr)
        return 'bullseye'
    except Exception as e:
        print(f"Warning: An error occurred while reading /etc/os-release: {e}. Falling back to Bullseye defaults.", file=sys.stderr)
        return 'bullseye'


class Report:
    def __init__(self, id, file):
        self._id = id
        self._cmds = []
        self._strs = []
        self._file = file

    def __run_cmd(self, cmd):
        print(f'** {cmd} **', file=self._file)
        try:
            p = subprocess.run(cmd, text=True, check=False, shell=True,
                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            print(p.stdout, file=self._file)
        except RuntimeError as e:
            print(f'Error: {e}', file=self._file)

    def add_cmd(self, c):
        self._cmds.append(c)

    def add_str(self, s):
        self._strs.append(s)

    def exec(self):
        print(f'{"-"*80}\\n{self._id}\\n{"-"*80}', file=self._file)
        for c in self._cmds:
            self.__run_cmd(c)
        for s in self._strs:
            print(s, file=self._file)


def run_prog(cmd, t):
    cmd_list = cmd.split(' ')
    out = []
    try:
        start = time.time()
        # Using cmd_list to avoid shell=True complexities unless necessary
        p = subprocess.Popen(cmd_list, text=True, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT, errors='ignore')
        poll = select.poll()
        poll.register(p.stdout, select.POLLIN)
        while p.poll() is None:
            if poll.poll(0):
                line = p.stdout.readline()
                print(line, end='', flush=True)
                out.append(line)
            if (t != 0) and (time.time() - start > t):
                p.kill()
                # Use communicate to get any remaining output
                remaining_output = p.communicate()[0]
                if remaining_output:
                     print(remaining_output, end='', flush=True)
                     out.append(remaining_output)
                timeout_msg = f'\\nError: ***** TIMEOUT after {t} seconds *****\\n'
                print(timeout_msg)
                out.append(timeout_msg)
                break
        # One last read after the process finished
        remaining_output = p.communicate()[0]
        if remaining_output:
             print(remaining_output, end='', flush=True)
             out.append(remaining_output)
    except KeyboardInterrupt:
        p.kill()
        out.append('\\nError: ***** INTERRUPT *****\\n')
    except FileNotFoundError:
        err_msg = f"\\nError: ***** COMMAND NOT FOUND: '{cmd_list[0]}' *****\\n"
        print(err_msg, file=sys.stderr)
        out.append(err_msg)
    p.wait()
    return ''.join(out)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='libcamera-apps Bug Report Generator')
    parser.add_argument('-o', help='Report filename',
                        type=str, default='arducam-bug-report.txt')
    parser.add_argument('-t', help='Timeout (seconds) for the camera command. Default is 8 seconds. Set to 0 to disable.',
                        type=float, default=8.0)
    parser.add_argument('-c', help='Command to run, e.g., -c "libcamera-still -t 5000 -n -o arducam-test.jpg"',
                        type=str, default=None)

    args = parser.parse_args()

    os_codename = get_os_codename()

    if args.c is None:
        if os_codename in ['bookworm', 'trixie']:
            print(f"[INFO] {os_codename.capitalize()} OS detected. Defaulting to 'rpicam-still'.")
            args.c = 'rpicam-still -n -t 1000 -o arducam-test.jpg --width 1920 --height 1080'
        else:
            print("[INFO] Bullseye or other OS detected. Defaulting to 'libcamera-still'.")
            args.c = 'libcamera-still -n -t 1000 -o arducam-test.jpg --width 1920 --height 1080'

    app = args.c.split(" ")[0]

    list_cameras_flag = '--list' if os_codename in ['bookworm', 'trixie'] and app.startswith('rpicam-') else '--list-cameras'


    reports = []
    with open(args.o, 'wt') as file:
        title = Report('libcamera-apps Bug Report', file)
        title.add_str(f'Date: {datetime.now().strftime("%d-%m-%Y (%H:%M:%S)")}')
        title.add_str(f'Command: {" ".join(sys.argv)}\\n')
        reports.append(title)

        hwinfo = Report('Hardware information', file)
        hwinfo.add_cmd('hostname')
        hwinfo.add_cmd('uname -r')
        hwinfo.add_cmd('cat /proc/cpuinfo | tail -n 4')
        reports.append(hwinfo)

        libcamerainfo = Report('libcamera verison', file)
        libcamerainfo.add_cmd('sudo dpkg -l | grep libcamera')
        reports.append(libcamerainfo)

        camera = Report('Camera detect', file)
        camera.add_cmd('ls /dev/video*')
        reports.append(camera)

        config = Report('Configuration', file)
        config.add_cmd('if [ -f /boot/config.txt ]; then cat /boot/config.txt; else echo "/boot/config.txt not found."; fi')
        config.add_cmd('if [ -f /boot/firmware/config.txt ]; then cat /boot/firmware/config.txt; else echo "/boot/firmware/config.txt not found."; fi')
        config.add_cmd('ls /boot/overlays/* | grep arducam')
        config.add_cmd('ls /boot/overlays/* | grep imx')
        config.add_cmd('ls /lib/modules/$(uname -r)/kernel/drivers/media/i2c')
        config.add_cmd('i2cdetect -y -r 10 || i2cdetect -y -r 0') # Try bus 0 if 10 fails
        reports.append(config)

        mem = Report('Memory', file)
        mem.add_cmd('cat /proc/meminfo | grep Cma')
        reports.append(mem)

        cam = Report('Cameras', file)
        cam.add_cmd(f'{app} {list_cameras_flag}')
        reports.append(cam)

        ver = Report('Versions', file)
        ver.add_cmd('uname -a')
        ver.add_cmd('cat /etc/os-release')
        reports.append(ver)

        if args.c:
            print(f"--- Running camera command with a {args.t}-second timeout ---")
            cmd_out = run_prog(args.c, args.t)
            cmd = Report(f'Command Output: {args.c}', file)
            cmd.add_str(cmd_out)
            reports.append(cmd)

        logs = Report('Logs', file)
        logs.add_cmd("ls -lh arducam-test.jpg")
        logs.add_cmd('dmesg | grep arducam')
        logs.add_cmd('dmesg | grep imx')
        logs.add_cmd('dmesg | grep ov9281')
        logs.add_cmd('dmesg | tail -n 100')
        reports.append(logs)

        for r in reports:
            r.exec()

        print(f'\\nBug report generated to {args.o}')
        print('Please upload this file when you contact support@arducam.com')
